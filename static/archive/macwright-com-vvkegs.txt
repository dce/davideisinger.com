   #[1]macwright.com - Micro [2]macwright.com - Micro

Tom MacWright

   tom@macwright.com

Tom MacWright

     * [3]Writing‚á
     * [4]Reading
     * [5]Photos
     * [6]Projects
     * [7]Drawings
     * [8]Micro
     * [9]About

Second-guessing the modern web

   The emerging norm for web development is to build a React single-page
   application, with server rendering. The two key elements of this
   architecture are something like:
    1. The main UI is built & updated in JavaScript using React or
       something similar.
    2. The backend is an API that that application makes requests against.

   This idea has really swept the internet. It started with a few major
   popular websites and has crept into corners like marketing sites and
   blogs.

   I‚Äôm increasingly skeptical of it.

   There is a sweet spot of React: in moderately interactive interfaces.
   Complex forms that require immediate feedback, UIs that need to move
   around and react instantly. That‚Äôs where it excels. I helped build the
   editors in [10]Mapbox Studio and [11]Observable and for the most part,
   React was a great choice.

   But there‚Äôs a lot on either side of that sweet spot.

   The high performance parts aren‚Äôt React. [12]Mapbox GL, for example, is
   vanilla JavaScript and probably should be forever. The level of
   abstraction that React works on is too high, and the cost of using
   React - in payload, parse time, and so on - is too much for any company
   to include it as part of an SDK. Same with the [13]Observable runtime,
   the juicy center of that product: it‚Äôs very performance-intensive and
   would barely benefit from a port.

   The less interactive parts don‚Äôt benefit much from React. Listing
   pages, static pages, blogs - these things are increasingly built in
   React, but the benefits they accrue are extremely narrow. A lot of the
   optimizations we‚Äôre deploying to speed up these things, things like
   bundle splitting, server-side rendering, and prerendering, are
   triangulating what we had before the rise of React.

   And they‚Äôre kind of messy optimizations. Here are some examples.

Bundle splitting.

   As your React application grows, the application bundle grows. Unlike
   with a traditional multi-page app, that growth affects every visitor:
   you download the whole app the first time that you visit it. At some
   point, this becomes a real problem. Someone who lands on the About page
   is also downloading 20 other pages in the same application bundle.
   Bundle splitting ‚Äòsolves‚Äô this problem by creating many JavaScript
   bundles that can lazily load each other. So you load the About page and
   what your browser downloads is an ‚Äòindex‚Äô bundle, and then that ‚Äòindex‚Äô
   bundle loads the ‚Äòabout page‚Äô bundle.

   This sort of solves the problem, but it‚Äôs not great. Most bundle
   splitting techniques require you to load that ‚Äòindex bundle‚Äô, and then
   only once that JavaScript is loaded and executed does your browser know
   which ‚Äòpage bundle‚Äô it needs. So you need two round-trips to start
   rendering.

   And then there‚Äôs the question of updating code-split bundles. User
   sessions are surprisingly long: someone might have your website open in
   a tab for weeks at a time. I‚Äôve seen it happen. So if they open the
   ‚Äòabout page‚Äô, keep the tab open for a week, and then request the ‚Äòhome
   page‚Äô, then the home page that they request is dictated by the index
   bundle that they downloaded last week. This is a deeply weird and
   under-discussed situation. There are essentially two solutions to it:
    1. You keep all generated JavaScript around, forever, and people will
       see the version of the site that was live at the time of their
       first page request.
    2. You create a system that alerts users when you‚Äôve deployed a new
       version of the site, and prompt them to reload.

   The first solution has a drawback that might not be immediately
   obvious. In those intervening weeks between loading the site and
   clicking a link, you might‚Äôve deployed a new API version. So the user
   will be using an old version of your JavaScript frontend with a new
   version of your API backend, and they‚Äôll trigger errors that none of
   your testing knows about, because you‚Äôll usually be testing current
   versions of each.

   And the second solution, while it works (and is what we implemented for
   Mapbox Studio), is a bizarre way for a web application to behave.
   Prompting users to ‚Äòupdate‚Äô is something from the bad old days of
   desktop software, not from the shiny new days of the web.

   Sure: traditional non-SPA websites are not immune to this pitfall.
   Someone might load your website, have a form open for many weeks, and
   then submit it after their session expired or the API changed. But
   that‚Äôs a much more limited exposure to failure than in the SPA case.

Server-Side Rendering

   Okay, so the theory here is that SPAs are initially a blank page, which
   is then filled out by React & JavaScript. That‚Äôs bad for performance:
   HTML pages don‚Äôt need to be blank initially. So, Server-Side Rendering
   runs your JavaScript frontend code on the backend, creating a
   filled-out HTML page. The user loads the page, which now has
   pre-rendered content, and then the JavaScript loads and makes the page
   interactive.

   A great optimization, but again, caveats.

   The first is that the page you initially render is dead: you‚Äôve created
   the [14]Time To Interactive metric. It‚Äôs your startup‚Äôs homepage, and
   it has a ‚ÄúSign up‚Äù button, but until the JavaScript loads, that button
   doesn‚Äôt do anything. So you need to compensate. Either you omit some
   interactive elements on load, or you try really hard to make sure that
   the JavaScript loads faster than users will click, or you make some
   elements not require JavaScript to work - like making them normal links
   or forms. Or some combination of those.

   And then there‚Äôs the authentication story. If you do SSR on any pages
   that are custom to the user, then you need to forward any cookies or
   authentication-relevant information to your API backend and make sure
   that you never cache the server-rendered result. Your
   formerly-lightweight application server is now doing quite a bit of
   labor, running React & making API requests in order to do this
   pre-rendering.

APIs

   The dream of APIs is that you have generic, flexible endpoints upon
   which you can build any web application. That idea breaks down pretty
   fast.

   Most interactive web applications start to triangulate on ‚Äúone query
   per page.‚Äù API calls being generic or reusable never seems to persist
   as a value in infrastructure. This is because a large portion of web
   applications are, at their core, query & transformation interfaces on
   top of databases. The hardest performance problems they tend to have
   are query problems and transfer problems.

   For example: a generically-designed REST API that tries not to mix
   ‚Äòconcerns‚Äô will produce a frontend application that has to make lots of
   requests to display a page. And then a new-age GraphQL application will
   suffer under the [15]N+1 query problem at the database level until an
   optimization arrives. And a traditional ‚Äúmake a query and put it on a
   page‚Äù application will just, well, try to write some good queries.

   None of these solutions are silver bullets: I‚Äôve worked with
   overly-strict REST APIs, optimization-hungry GraphQL APIs, and
   hand-crafted SQL APIs. But no option really lets a web app be careless
   about its data-fetching layer. Web applications can‚Äôt sit on top of
   independently-designed APIs: to have a chance at performance, the
   application and its datasource need to be designed as one.

Data fetching

   Speaking of data fetching. It‚Äôs really important and really bizarre in
   React land. Years ago, I expected that some good patterns would emerge.
   Frankly, they didn‚Äôt.

   There are decent patterns in the form of GraphQL, but for a React
   component that loads data with fetch from an API, the solutions have
   only gotten weirder. There‚Äôs great documentation for everything else,
   but old-fashioned data loading is relegated to one example of how to
   mock out ‚Äòfetch‚Äô for testing, and lots of Medium posts of varying
   quality.
     __________________________________________________________________

   Don‚Äôt read this as anti-React. I still think React is pretty great, and
   for a particular set of use cases it‚Äôs the best tool you can find. And
   I explicitly want to say that ‚Äì from what I‚Äôve seen ‚Äì most other
   Single-Page-Application tools share most of these problems. They‚Äôre
   issues with the pattern, not the specific frameworks used to implement
   it. React alternatives have some great ideas, and they might be better,
   but they are ultimately really similar.

   But I‚Äôm at the point where I look at where the field is and what the
   alternative patterns are ‚Äì taking a second look at unloved, unpopular,
   uncool things like Django, Rails, Laravel ‚Äì and think what the heck is
   happening. We‚Äôre layering optimizations upon optimizations in order to
   get the SPA-like pattern to fit every use case, and I‚Äôm not sure that
   it is, well, worth it.

   And it should be easy to do a good job.

   Frameworks should lure people into the [16]pit of success, where
   following the normal rules and using normal techniques is the winning
   approach.

   I don‚Äôt think that React, in this context, really is that pit of
   success. A na√Øvely implemented React SPA isn‚Äôt stable, or efficient,
   and it doesn‚Äôt naturally scale to significant complexity.

   You can add optimizations on top of it that fix those problems, or you
   can use a framework like Next.js that will include those optimizations
   by default. That‚Äôll help you get pretty far. But then you‚Äôll be lured
   by all of the easy one-click ways to add bloat and complexity. You‚Äôll
   be responsible for keeping some of these complex, finicky optimizations
   working properly.

   And for what? Again - there is a swath of use cases which would be hard
   without React and which aren‚Äôt complicated enough to push beyond
   React‚Äôs limits. But there are also a lot of problems for which I can‚Äôt
   see any concrete benefit to using React. Those are things like blogs,
   shopping-cart-websites, mostly-[17]CRUD-and-forms-websites. For these
   things, all of the fancy optimizations are trying to get you closer to
   the performance you would‚Äôve gotten if you just hadn‚Äôt used so much
   technology.

   I can, for example, guarantee that this blog is faster than any Gatsby
   blog (and much love to the Gatsby team) because there is nothing that a
   React static site can do that will make it faster than a non-React
   static site.
     __________________________________________________________________

   But the cultural tides are strong. Building a company on Django in 2020
   seems like the equivalent of driving a PT Cruiser and blasting Faith
   Hill‚Äôs ‚ÄúBreathe‚Äù on a CD while your friends are listening to The Weeknd
   in their Teslas. Swimming against this current isn‚Äôt easy, and not in a
   trendy contrarian way.

   I don‚Äôt think that everyone‚Äôs using the SPA pattern for no reason. For
   large corporations, it allows teams to work independently: the
   ‚Äúfrontend engineers‚Äù can ‚Äúconsume‚Äù ‚ÄúAPIs‚Äù from teams that probably work
   in a different language and can only communicate through the hierarchy.
   For heavily interactive applications, it has real benefits in
   modularity, performance, and structure. And it‚Äôs beneficial for
   companies to shift computing requirements from their servers to their
   customers browsers: a real win for reducing their spend on
   infrastructure.

   But I think there are a lot of problems that are better solved some
   other way. There‚Äôs no category winner like React as an alternative.
   Ironically, backends are churning through technology even faster than
   frontends, which have been loyal to one programming language for
   decades. There are some age-old technologies like Rails, Django, and
   Laravel, and there are a few halfhearted attempts to do templating and
   ‚Äúserve web pages‚Äù from Go, Node, and other new languages. If you go
   this way, you‚Äôre beset by the cognitive dissonance of following in the
   footsteps of enormous projects - Wikipedia rendering web pages in PHP,
   Craigslist rendering webpages in Perl - but being far outside the norms
   of modern web development. If Wikipedia were started today, it‚Äôd be
   React. Maybe?

   What if everyone‚Äôs wrong? We‚Äôve been wrong before.
   Follow-ups & commmentary
     * [18]"In defense of the modern web", Rich Harris
     * [19]Friday Night Deploys (Podcast) #22: A Brief Discussion On The
       State Of The Modern Web
     * [20]Frontend First (Podcast): Read & Discuss
     * [21]A Ready-To-Try Concept in Response to ‚ÄúSecond-guessing the
       modern web‚Äù

   May 10, 2020  [22]Tom MacWright ([23]@tmcw, [24]@tmcw@mastodon.social)

References

   1. https://macwright.com/micro/rss.xml
   2. https://macwright.com/micro/atom.xml
   3. https://macwright.com/
   4. https://macwright.com/reading/
   5. https://macwright.com/photos/
   6. https://macwright.com/projects/
   7. https://macwright.com/drawings/
   8. https://macwright.com/micro/
   9. https://macwright.com/about/
  10. https://www.mapbox.com/mapbox-studio/
  11. https://observablehq.com/
  12. https://docs.mapbox.com/mapbox-gl-js/api/
  13. https://github.com/observablehq/runtime
  14. https://web.dev/interactive/
  15. https://engineering.shopify.com/blogs/engineering/solving-the-n-1-problem-for-graphql-through-batching
  16. https://blog.codinghorror.com/falling-into-the-pit-of-success/
  17. https://en.wikipedia.org/wiki/Create,_read,_update_and_delete
  18. https://dev.to/richharris/in-defense-of-the-modern-web-2nia
  19. https://dev.to/devplebs/friday-night-deploys-22-a-brief-discussion-on-the-state-of-the-modern-web-2961
  20. https://frontendfirst.fm/episodes/read-and-discuss-second-guessing-the-modern-web
  21. https://medium.com/@kevinkirchner/a-ready-to-try-concept-in-response-to-second-guessing-the-modern-web-6946ec4d0598
  22. https://macwright.com/about/
  23. https://twitter.com/intent/follow?screen_name=tmcw&user_id=1458271
  24. https://mastodon.social/@tmcw
